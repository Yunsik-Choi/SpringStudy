
아래 글의 더 자세한 내용은
https://durumiss.tistory.com/4 에서 확인하실 수 있습니다.

## **개요**

클래스와 객체를 정확하게 이해하기 위해서는 붕어빵틀과 붕어빵의 관계로 이해하면 안된다.

클래스와 객체를 정확하게 이해하기 위해서는 사람과 홍길동 또는 사람과 줄리엣 또는 사람과 김연아 등의 관계로 이해하는 것이 좋다. 또한 객체는 사전적으로 세상에 존재하는 유일무이한 사물로 볼 수 있다. 프로그래밍에서는 객체는 클래스의 인스턴스이다. 그리고 애플리케이션 컨텍스트(경계)에 맞게 설계를 해야한다. (ex, 병원...)

## **추상화**

추상화는 사전적으로 공통 특성/공통 속성 추출으로 볼 수 있다.

사람을 만들때 사람의 공통된 특성을 먼저 찾게 된다. 그것을 변수로 두고 사람의 기능/행위가 메소드로 설정한다.

추상화

OOP의 추상화는 모델링이다

클래스:객체 \= 사람:김연아

클래스 설계에서 추상화가 사용된다

클래스 설계를 위해서는 애플리케이션 경계부터 정한다

객체 지향에서 추상화의 결과는 클래스다

static 변수는 클래스로 생성된 객체들끼리 공유하는 변수이다.

## **상속**

![](https://blog.kakaocdn.net/dn/btQhP8/btq09ypd25K/Fd1sIEh2pTqnAH1JpnMWH0/img.png)

객체지향에서 상속은 할아버지-아빠-아들과 같은 의미가 아니라 상위 클래스의 특성을 하위 클래스에서 상속하고 거기에 더해 필요한 특성을 추가, 확장해서 사용할 수 있다는 의미이다.

객체 지향의 상속은 상위 클래스의 특성을 재사용하는 것이다.

객체 지향의 상속은 상위 클래스의 특성을 확장하는 것이다.

객체 지향의 상속은 is a kind of 관계를 만족해야 한다.(is a보다는 is a kind of가 더 명확한 표현이다)

#### 인터페이스\-->'~무엇을 할 수 있는'과 같은 형태로 만드는 것이 좋다


![](https://blog.kakaocdn.net/dn/ckAUih/btq1cagoGcl/AQJSfhjnc0AXHBEmvD3dV1/img.png)

상위 클래스는 LSP를 만족시키기 위해 물려줄 특성이 풍성할 수록 좋다.

LSP는 프로그램의 객체는 프로그램의 정확성을 깨뜨리지 않으면서 하위 타입의 인스턴스로 바꿀수 있어야 한다는 것이다.

인터페이스는 ISP를 만족시키기 위해 구현을 강제할 메서드의 개수가 적을수록 좋다.

ISP는

• 특정 클라이언트를 위한 인터페이스 여러 개가 범용 인터페이스 하나보다 낫다

• 자동차 인터페이스 \-> 운전 인터페이스, 정비 인터페이스로 분리

• 사용자 클라이언트 \-> 운전자 클라이언트, 정비사 클라이언트로 분리

과 같은 특성이다.

## **다형성**

오버로딩과 오버라이딩

오버로딩 \- > 같은 메서드 이름, 같은 인자 목록으로 상위 클래스의 메서드를 재정의

오버라이딩 \-> 같은 메서드 이름, 다른 인자 목록으로 다수의 메서드를 중복 정의

상위 클래스 타입의 객체 참조 변수를 사용하더라도 하위 클래스에서 오버라이딩한메소드가 호출된다

## **캡슐화**

접근 제어자가 객체 멤버와 쓰일때와 정적멤버와 쓰일 때의 차이를 이해해야 한다.

CallbyValue

기본자료형 변수는 저장하고 있는 값을 그 값 자체로 해석

CallbyReference

객체 참조 변수는 저장하고 있는 값을 주소(포인터)로 해석
